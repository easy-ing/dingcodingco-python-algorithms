# 딩코딩코 Chapter 1 - 1주차 마무리

# **이번 주 핵심 요약**

- **Q1(소수)**: “나눠보는 방식” → “이미 찾은 소수만으로 검사” → 최종적으로는 **에라토스테네스의 체(배수 지우기)** 가 가장 표준/효율적
- **Q2(문자열 뒤집기)**: “뒤집는 구간”은 **0↔1이 바뀌는 지점**에서 생김 → 결국 **0 덩어리 개수 vs 1 덩어리 개수** 중 작은 값이 답
- **문자열 요약**: 연속 구간을 세면 됨 → “현재 문자 연속 길이”를 누적하다가 바뀌면 출력에 붙임

---

# **Q1. ✍️ 소수 나열하기 (BOJ 1929)**

> **M 이상 N 이하 소수 출력**
> 

## **1) 기본 풀이(비효율) 아이디어**

- n이 소수인지 확인하려고 **2부터 n-1까지 전부 나눠봄**
- 나누어 떨어지면 소수 아님, 끝까지 안 나누어 떨어지면 소수

### **단점**

- 매 n마다 거의 n번 나누게 될 수 있어 느림

---

## **2) 1차 개선 아이디어**

- “모든 수”가 아니라 **이미 찾은 소수(primeList)** 로만 나눠봄
- 그래도 아직 개선 여지가 있음

---

## **3) 2차 개선 핵심(현재 자바 코드의 포인트)**

- i * i <= n까지만 검사하면 됨
    - √n보다 큰 약수는 √n보다 작은 약수와 “짝”으로 이미 등장했기 때문

---

## **✅ 최종 추천: 에라토스테네스의 체 (가장 표준)**

### **아이디어**

- isPrime[0..N] 배열을 만들고
- 2부터 시작해서 소수인 수 p를 만나면 **p의 배수들을 전부 제거(false)**

### **시간 복잡도**

- 대략 **O(N log log N)** 로 매우 빠름 (실전에서 가장 많이 씀)

---

## **Java 풀이**

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int M = Integer.parseInt(st.nextToken());
        int N = Integer.parseInt(st.nextToken());

        boolean[] isPrime = new boolean[N + 1];
        Arrays.fill(isPrime, true);
        if (N >= 0) isPrime[0] = false;
        if (N >= 1) isPrime[1] = false;

        for (int p = 2; p * p <= N; p++) {
            if (!isPrime[p]) continue;
            for (int multiple = p * p; multiple <= N; multiple += p) {
                isPrime[multiple] = false;
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = M; i <= N; i++) {
            if (isPrime[i]) sb.append(i).append('\n');
        }
        System.out.print(sb.toString());
    }
}
```

## **(참고) “N 이하 소수 리스트”만 원하면?**

- 입력이 N 하나라면, 출력 루프만 2..N으로 돌리고 isPrime[i] 출력하면 끝

---

# **Q2. ✍️ 문자열 뒤집기**

## **문제 핵심 해석**

- 뒤집는 행동 = **연속된 구간** 하나를 잡아서 0↔1로 바꾸는 것
- 최소 횟수로 전부 0 또는 전부 1로 만들기

**✅ 핵심**

- 문자열을 왼쪽부터 볼 때, 값이 바뀌는 순간(0↔1)이 **구간이 끊기는 지점**
- 결국
    - 0 덩어리 개수 = countGroup0
    - 1 덩어리 개수 = countGroup1
- 정답 = min(countGroup0, countGroup1)

예) 0001100

- 0 덩어리: 000 / 00 → 2개
- 1 덩어리: 11 → 1개
- 답 = 1

## **시간 복잡도**

- 문자열 한 번 순회 → **O(N)**

## **Java 풀이**

```java
class FindCountToTurnOutToAllZeroOrAllOne {
    public static int solve(String s) {
        int group0 = 0;
        int group1 = 0;

        // 첫 글자로 첫 덩어리 카운트
        if (s.charAt(0) == '0') group0++;
        else group1++;

        // 이전 글자와 달라지는 순간 = 새 덩어리 시작
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) != s.charAt(i - 1)) {
                if (s.charAt(i) == '0') group0++;
                else group1++;
            }
        }
        return Math.min(group0, group1);
    }

    public static void main(String[] args) {
        System.out.println(solve("0001100")); // 1
        System.out.println(solve("011110"));  // 테스트
    }
}
```

---

---

# **🎆 문자열 요약해보기 (연속 문자 + 개수 출력)**

## **문제 조건**

- 입력 문자열은 **알파벳 오름차순 정렬**
- 같은 알파벳이 연속으로 중복될 수 있음
- 없는 알파벳이 중간에 있을 수도 있음
- 출력 형식 예: a1/c3/d1/e3 (마지막은 / 없이)

---

## **✅ 풀이 아이디어**

- 현재 문자의 연속 개수 count를 세다가,
- 다음 문자로 바뀌는 순간 “문자+개수/”를 결과에 붙이고 count 리셋
- 마지막 문자는 루프 밖에서 한 번 더 붙임

## 파이썬 풀이

```python
def summarize_string(target_string):
    if not target_string:
        return ""

    n = len(target_string)
    count = 1
    result = []

    for i in range(1, n):
        if target_string[i] == target_string[i - 1]:
            count += 1
        else:
            result.append(f"{target_string[i-1]}{count}")
            count = 1

    result.append(f"{target_string[n-1]}{count}")
    return "/".join(result)

print(summarize_string("abc"))       # a1/b1/c1
print(summarize_string("aaabbbc"))   # a3/b3/c1
print(summarize_string("ahhhhz"))    # a1/h4/z1
print(summarize_string("acccdeee"))  # a1/c3/d1/e3
```
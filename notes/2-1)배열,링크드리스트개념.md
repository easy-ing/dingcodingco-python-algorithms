# 딩코딩코 Chapter2 - Array & Linked List

## **Array-배열**

### **핵심 개념**

- 배열은 **연속된 공간에 데이터(원소)를 순서대로 저장**하는 자료구조
- 각 원소는 **인덱스(index)** 로 접근하며, 보통 **0부터 시작**

### **특징 요약**

- **크기가 고정**됨
    - 처음 방(공간) 개수를 정하면 **중간에 크기 변경이 어렵다**
- **빠른 접근(조회)**
    - rooms[0] 처럼 **원하는 위치를 바로 접근 가능**
    - 시간복잡도: **O(1)**
- **중간 삽입/삭제가 느림**
    - 혜인이를 중간으로 옮기려면, 뒤에 있는 원소들을 **한 칸씩 밀거나 당겨야 함**
    - 최악의 경우 N개 이동 → 시간복잡도: **O(N)**
- **원소 추가(확장)가 비효율적일 수 있음**
    - 공간이 꽉 차면 **더 큰 배열을 새로 만들고 복사**해야 함(새 호텔 건설)
    - 비용(시간/메모리) 증가

### **한 줄 결론**

- 배열은 **조회는 빠르지만(O(1))**, **중간 삽입/삭제·확장은 느리다(O(N))**.

---

## **Linked List**

### **핵심 개념**

- 링크드 리스트는 **노드(Node)** 들이 **포인터(연결고리)** 로 다음 노드를 가리키며 연결된 자료구조
- 메모리에 **연속으로 붙어 있지 않아도** 연결만 되면 리스트가 됨

---

### **특징 요약**

- **크기 가변(유연함)**
    - 칸(노드)을 **붙이기만 하면 늘릴 수 있음**
    - 배열처럼 “새로 크게 짓고 복사”가 필수는 아님
- **특정 원소 접근(조회)이 느림**
    - 우편칸에 가려면 앞 칸부터 **하나씩 따라가며 탐색**해야 함
    - 최악: N개 전부 확인 → 시간복잡도 **O(N)**
- **중간 삽입/삭제가 빠름 (조건 있음)**
    - 흑연 칸 추가 / 밀가루 칸 삭제처럼
    - **앞뒤 연결고리(포인터)만 바꾸면 됨**
    - “이미 그 위치(노드)를 알고 있다면” 삽입/삭제는 **O(1)**
    - 단, **그 위치를 찾는 과정**이 필요하면 찾는 데 **O(N)** 이 걸릴 수 있음

---

### **한 줄 결론**

- 링크드 리스트는 **조회는 느리지만(O(N))**, **(위치를 알고 있으면) 중간 삽입/삭제는 빠르다(O(1))**.

---

# Array vs LinkedList

![스크린샷 2025-12-26 오전 9.56.16.png](%EB%94%A9%EC%BD%94%EB%94%A9%EC%BD%94%20Chapter2%20-%20Array%20&%20Linked%20List/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-12-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.56.16.png)
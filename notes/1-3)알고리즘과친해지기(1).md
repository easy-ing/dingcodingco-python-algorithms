# 딩코딩코 Chapter 1 - 알고리즘과 친해지기 (1)

## 최댓값 찾기

> 🎯 목표: 배열에서 최댓값을 찾는 2가지 방법을 비교하고, 시간복잡도 차이(O(N²) vs O(N))를 체감한다.
> 

---

### ✅ 문제 요약

- **입력:** 숫자로 이루어진 배열 `array`
- **출력:** 배열 안의 **최댓값(max)**

**예시**

- `[3, 5, 6, 1, 2, 4]` → `6`
- `[6, 6, 6]` → `6`
- `[6, 9, 2, 7, 1888]` → `1888`

---

## 1) 접근 방법 A1: 모든 값과 비교해서 “최댓값인지” 확인하기 (완전탐색)

### 💡 아이디어

- 배열의 각 원소 `number`에 대해,
- 다른 모든 원소 `compareNumber`와 비교한다.
- 한 번이라도 더 큰 값이 있으면 최댓값이 아니다.
- 끝까지 살아남으면 그 값이 최댓값이다.

### ✅ Java 코드

```java
class FindMaxNum1 {
    public static int findMaxNum(int[] array) {
        for (int number : array) {
            boolean isMaxNum = true;
            for (int compareNumber : array) {
                if (number < compareNumber) {
                    isMaxNum = false;
                }
            }
            if (isMaxNum) {
                return number;
            }
        }
        return 0;
    }
}
```

### **⏱️ 시간복잡도**

- 바깥 반복문 N × 안쪽 반복문 N → **O(N²)**

### **📝 느낀점**

- “최댓값인지 확인”하려면 결국 전부 비교해야 한다.
- 배열이 커지면 급격히 느려질 수 있다.

---

## **2) 접근 방법 A2: 최댓값을 변수로 저장하며 한 번만 순회하기**

### **💡 아이디어**

- max_num을 배열의 첫 값으로 시작한다.
- 배열을 순회하며 더 큰 값을 만나면 max_num을 갱신한다.
- 한 번 다 돌면 max_num이 최댓값이다.

### ✅ Java 코드

```java
class FindMaxNum2 {
    public static int findMaxNum(int[] array) {
        int maxNum = array[0];
        for (int num : array) {
            if (num > maxNum) {
                maxNum = num;
            }
        }
        return maxNum;
    }
}
```

### **⏱️ 시간복잡도**

- 한 번 순회 → **O(N)**

### **📝 느낀점**

- 굳이 전부 비교할 필요 없이, **현재까지의 최고값만 기억**하면 된다.
- 실전에서는 이 방식이 훨씬 효율적이다.

---

## GPT 사용해서 표로 정리

![스크린샷 2025-12-24 오후 11.26.23.png](%EB%94%A9%EC%BD%94%EB%94%A9%EC%BD%94%20Chapter%201%20-%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%20(1)/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-12-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.26.23.png)

## **✅ 한 줄 결론**

- 최댓값 찾기는 **변수 하나를 두고 갱신하면서 한 번만 순회(O(N))** 하는 방식이 가장 깔끔하고 효율적이다.
# 딩코딩코 Chapter 1 - 시간복잡도 & 공간복잡도

## ✅ 시간 복잡도 / 공간 복잡도 한 번에 정리

### 1) 시간 복잡도(Time Complexity)란?

- **입력값(N)** 이 커질 때, 문제를 해결하는 데 필요한 **연산량(=걸리는 시간)이 얼마나 늘어나는지**를 보는 기준
- 핵심 포인트: 입력이 2배가 되면 **시간이 몇 배로 늘어나는지**를 본다
- 분석 팁(간단 버전)
    - “한 줄 실행 = 1번 연산”처럼 두고,
    - 반복문이 **몇 번 도는지(N, N², …)** 를 중심으로 계산한다
- 실제 표현은 **Big-O(빅오)** 로 정리한다
    - 예: `2N² + N` → 중요한 건 `N²` → **O(N²)**
    - 예: `2N + 1` → 중요한 건 `N` → **O(N)**
- 결론: **상수(2, +1 등)는 무시**, **가장 큰 차수(지수)가 시간복잡도를 결정**한다

---

### 2) 최댓값 찾기 시간 복잡도 비교

### 방법 1) 모든 값과 전부 비교(이중 반복)

- 바깥 반복: N번
- 안쪽 반복: N번
- 대략 연산량: `2N² + N`
- **시간 복잡도: O(N²)**

### 방법 2) 한 번 훑으며 최댓값 갱신

- 배열을 1번 순회: N번
- 대략 연산량: `2N + 1`
- **시간 복잡도: O(N)**

✅ **정리:** N이 커질수록 **O(N)** 이 **O(N²)** 보다 압도적으로 빠르다

---

### 3) 최빈값(가장 많이 등장한 알파벳) 시간 복잡도 비교

> 문자열 길이를 M이라고 하자.
> 

### 방법 1) 알파벳(26개)을 하나씩 골라서 문자열 전체를 매번 확인

- 알파벳 반복: 26번(상수)
- 문자열 순회: M번
- 총 연산: `26 * M`
- **시간 복잡도: O(M)** (26은 상수라 무시)

### 방법 2) 빈도수 배열(26칸)에 한 번에 누적 + 마지막에 최댓값 찾기

- 문자열 1회 순회: M번
- 26칸 배열에서 최대 찾기: 26번(상수)
- 총 연산: `M + 26`
- **시간 복잡도: O(M)**

✅ **정리:** 둘 다 Big-O로는 **O(M)** 이지만,

실제로는 **방법 2가 상수항이 작고 구조가 깔끔해서 더 좋은 구현**인 경우가 많다

---

## ✅ 공간 복잡도(Space Complexity)란?

- 입력값(N)이 커질 때, 문제를 푸는 데 필요한 **메모리(공간)가 얼마나 늘어나는지**를 보는 기준
- 핵심 포인트: 입력이 2배가 되면 **공간이 몇 배로 늘어나는지**를 본다
- 보통 “추가로 쓰는 메모리(보조 공간)”를 중심으로 판단한다
    - 예: 새 배열 만들기, 딕셔너리/해시맵, 재귀 호출 스택 등

---

### 4) 예제들의 공간 복잡도(추가 공간 기준)

### 최댓값 찾기

- 방법 1: 비교용 변수만 사용 → **공간 복잡도 O(1)**
- 방법 2: max 변수만 사용 → **공간 복잡도 O(1)**

### 최빈값 찾기

- 방법 1: 카운트 변수들만 사용(알파벳 26개는 상수) → **O(1)**
- 방법 2: 빈도 배열 26칸 사용(상수 크기) → **O(1)**
    - (참고) 만약 “알파벳 종류가 K개”처럼 일반화하면 배열/딕셔너리는 **O(K)** 로 볼 수도 있음

---

## ✅ 빠른 결론(시험/면접용 한 줄)

- **시간:** 이중 반복이면 보통 **O(N²)**, 한 번만 훑으면 **O(N)**
- **공간:** 추가 배열/딕셔너리를 만들면 **O(N) 또는 O(K)**, 변수 몇 개면 **O(1)**